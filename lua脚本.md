**Lua语言学习**

----------

只要有c编译器的地方，就可以借此运行lua脚本，而我们这里学习lua也是因为redis需要借助它，来完成许多原子化操作。

# redis使用lua

首先就是redis如何使用lua来完成操作，虽然可以进入redis之后使用类似`eval`命令直接执行lua语句，但是，我们可能更希望直接让脚本文件完成一系列的操作，

原始的redis使用，需要`redis-cli -a 密码 --eval lua脚本路径  键名1 键名2 ..., 参数1 参数2 ...`。

如果是java等项目，则可以添加Jedis或spring家族的spring-boot-starter-data-redis，创建产生redis的实例后，一般在对应的execute方法中就存在操作脚本的命令，同样的，指定脚本的位置或生成一个该文件的流，在指定键名队列，和若干参数即可。

而关键的lua脚本内部如何编写

> 针对redis环境下，可以直接在内部操作redis，比如，我们输入了一个键名，希望的对应的字符串变成我输入的哪个参数
>
> ```lua
> redis.call('set',KEYS[1],ARGV[1]);
> -- KEYS[1]就是提取键名中的第一个，ARGV[1]自然就是提取参数中的第一个
> -- 直接使用'set',表明调用的是set命令
> ```
>
> 一个普通的关于redis的lua脚本就是这么简单，关于redis的大多数操作，就是call函数加上对应的命令字符串，附带需要的参数即可。

# 基本的lua语法

前面基本就可以帮助我们随便乱改redis的内容，但是，lua作为我们实现原子化操作的手段，自然需要具备判断循环之类的操作

> 判断语句的特别之处在于最后需要一个`end`作为结束
>
> ```lua
> if 判断 then 
>     语句
> elseif 判断 then
>     语句
> else
>     语句
> end
> ```

> 循环的方法就比较多了
>
> ```lua
> while 条件 do
>     语句
> end
> ```
>
> ```lua
> repeat
>     语句
> until 条件
> ```
>
> ```lua
> for 变量初始化,判断,变量操作 do
>     语句
> end
> -- 也可以是循环某个列表元素的
> for 元素名 in 列表名 do
>     语句 
> end
> ```

此外，自定义函数，

> ```lua
> function 函数名 (可能的参数) -- 可以使用 ... 表示不定量参数
>     语句
> end
> -- lua中的函数 是可以返回多个值的
> -- 比如 return min,max
> -- 即可以返回计算结果中的最小值和最大值
> ```

分号在lua中表示一个代码块的结束，就好像我们编写sql语句，写了一大堆之后才写个`;`，表示一条完整的语句，而这一个代码块中就延伸出哪些变量是全局的或是局部的。

# 变量

空值用`nil`表示，和很多脚本语言类似，lua没有强制变量类型，变量可以直接定义，

```lua
a=3
a="s"
a=0.1
-- 都是可以的，且这样的定义，变量默认是全局变量
local a=9 -- 则表示变量是局部变量
-- local 除了可以修饰变量，还可以让函数变成私有函数
```

可以用`type函数给出变量的类型`，如`type(a)`就可以得出变量 a 的实际类型，而lua提供的类型有

`nil、boolean、number、string、userdata、function、thread 和 table`

如果想实现类似字符串拼接，则需要两个变量使用`..`连接，比如`a .. b`，注意两个变量不要和`..`碰到。

而逻辑判断的方法和python相似，使用了`and`，`not`，`or`。

## 变量集合体

数组创建就是`{}`表示初始化

```lua
a={} -- 创建数组成功
a[1=值 -- 强行赋值，编号从1开始
```

```lua
for i=1,N do -- 多维创建，N行M列
    a[i] = {}
        for j=1,M do
        	a[i][j] = 0
    end
end
```

上述的操作其实就是lua中表的一种创建，就是哪个变量类型`table`，是一种重要的类型，能简单的生成数组，还具有其它操作手法，

```lua
a={a1=0,a2="s"} -- 可以为内部的值命名
b={}
a.a3=b -- 添加新元素，不论对方什么类型
a.a1=nil -- 实际就是删除了a1
```

建立一个链表，实际还是table类型的，

```lua
a=nil -- 链头的初始化
a={next=list,value=值} -- 实际就是有着明确元素名称的table,这就实现的一个链表，循环语句多高几下就可以了
a.value -- 给出值
a=a.next -- 在链表上滑动
```

# 基本操作

表

```lua
-- a 为数组
table.getn(a) -- 返回数组元素个数，但空值不算。响应的setn是设置大小
table.insert(a,位置编号,值) -- 在对应的位置上插入新值
-- 还可以排序，和其它语言一样，排序可以指定一个参数表明排序的依据，这里要求元素按字符串的字典顺序
table.sort(a, function (x, y) return string.lower(x) < string.lower(y) end)
-- 这里无视大小写
```

字符串

```lua
-- 上面已经提及了字符的大小写转换
string.sub(字符串变量名,开始编号，结尾编号) -- 字符串截取，编号可以是负数，表示倒数
-- 编号是从1开始
string.char(acsii数) -- 将整数转化为对应的字符,可以写多个整数，输出字符串
string.byte(字符串变量名,字符所在位置编号) -- 给出对应字符的acsii数
string.format("",) -- 与其它语言一样，原有的字符串中用`%`跟着f或d或s表示放置浮点数或整数或字符串
-- 额外的如`%.3f`表示浮点数只会保留小数点后3位，`%03d`表示整数只会保留3位，不足就用'0'替代
string.find(字符串变量名,子字符串) -- 在指定的字符串中搜索子字符串，如有，就返回所在的开始编号和结束编号
string.gsub(字符串变量名,匹配字符串,替换字符串) -- 这里是在指定字符串中搜索是否存在匹配字符串，如有，就用替换字符串替代
-- 将返回一个新的字符串，需要接收
tonumber(字符串) -- 可以将数值字符串转变成对应的数值

-- 模式
s = "Deadline is 30/05/1999, firm"
date = "%d%d/%d%d/%d%d%d%d"
print(string.sub(s, string.find(s, date))) --> 30/05/1999
```

```
.  任意字符
%a 字母
%c 控制字符
%d 数字
%l 小写字母
%p 标点字符
%s 空白符
%u 大写字母
%w 字母和数字
%x 十六进制数字
%z 代表 0 的字符
```

