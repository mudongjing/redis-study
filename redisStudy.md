**redis基本功能使用**

---------------------------

# 基础的基础

redis的操作主要使用了几种特定的数据结构，不同于mysql之类的规定了数据存储就是建立数据表，然后向其中填写数据。

使用redis没有数据表的概念，库的话勉强算有，但不能自定义名字，只是指定了库的编号，默认16个。

对于存储数据，就是在自己指定的一个数据库中，创建一个数据结构，然后直接填写数据即可。

> 所谓数据结构，就是我们常见的键值对，不同点在于其中的值，可以是普通的字符串，或是列表，哈希表，集合，有序列表

换言之，在redis上存储数据，本质可以看作是在一个哈希表中创建一个key键，然后规定了对应的值的结构，在填写数据。

比如，我们登录到redis之后，

> 通过`select`选择一个数据库，默认就是`0`号数据库，也可以是`select 5`，即选择编号为5的数据库。
>
> 选择完毕后，通过set就是创建了我们的一个类似数据表的东西，但是对于不同的数据结构，这个set是不一样的，
>
> redis中不需要先创建再使用，直接上来就是用，如果没有对应的键就会自动给你创建。
>
> > 对于最简单的结构，就是一个字符串，就使用set。`set 键 值即字符串`。
> >
> > 对于列表就是`lpush`或`rpush`，这是向列表填入数据，顺便给创建出来，而且redis所谓的列表是一个双向链表。
> >
> > 哈希表或字典，使用`hset`创建，`hset 键名 哈希表的一个键名 对应的键值`
> >
> > 集合，使用`sadd`
> >
> > 有序列表，使用`zset`,这个结构，对于值具有集合的唯一性，而每个值又被赋予一个score值，作为依据实现有序。内部实现依赖跳表结构。

# 设置（set）

## 锁

redis的创建的键值可以设置存活期限，比如5秒后制动删除，使用`expire 键名 时间`。

对于一些场景，可以使用redis创建锁，比如规定在redis中创建某个键即获得一个锁，销毁后其它线程再创建就获得新的锁

> 当然，内部可以使用一个随机值作为某个线程的凭证，一次控制这个键值的存活

为了满足并发以及发生异常当情况，我们需要这个键值有一个过期时间，但是极端场景下，可能创建键值与设置期限两个步骤无法合法的完成，就需要一个特殊的命令实现两个步骤的原子化操作

```
SET 键名 v值 NX EX 秒数
# NX 是值只有当前不存在对应的键名才可以操作
# EX 就是值设置过期时间，这里是秒
# 如果希望设置为毫秒数， 则使用 PX 参数替代
```

> 这里，分布式锁实际还需要考虑操作超时的问题，实际也就是前面设置凭证的工作，需要一个对应的凭证才能删除该键值。
>
> 这里为了安全，就需要使用lua脚本完成识别凭证和删除的原子化操作。

## 位图

位图实际就是比特数组，在很多场景下，我们的记录可能就是有或无的两种状态，那么一个比特就足够。位图跟重要的用处在于之后的过滤器。

在redis中，比特数组实际就是字符串，一个字符由8个比特记录，多长的字符串也就能得出由多大的比特数，实际的操作对象就是简单的字符串结构，

```
setbit 键名 数组位置 新值0或1
# 数组位置从0开始计数
```

> 需要清醒的是，比特数组就是字符串，出来把他当作比特数组逐个位地操作，必要情况也可以作为字符串整体修改

如果是修改比特数组的局部区域，比如让数组中某个区域对应的结果设置为某个值，比如0位置向后8个位置如果作为字符是a，我们可以修改这个区域的结果成为其它字符，

```
bitfield 键名 set u数量 位置 新值
# 或
bitfield 键名 set i数量 位置 新值

# u和i分别对应无符号数和有符号数
# 数量就是我们希望 从对应的位置开始向后指定数量比特的区域，将修改为对应新值
# 比如，原有的哪个区域对应的是某个字符，我们希望修改这个字符为`a`，由于`a`对应的数值为无符号数97，就有
# bitfield 键名 set u8 位置 97
# 无符号数最多负责的数量是63，有符号数则是64
```

通过`bitfield`也可以在一条命令里对一个字符串进行多个位置区域的操作

```
bitfield 键名 set i数量1 位置1 新值1 set u数量2 位置2 新值2
```

除了直接设置新值，还可以对其进行自增，

```
bitfield 键名 incrby u数量 位置 增值
# 上述是作为无符号处理，也可使有符号数
# 主要是将对应区域的结果看作一个无符号数或有符号数进行增值操作
```

> 但是自增的一个问题在于，不注意的话可能会溢出，这里有几种处理溢出的命令
>
> WRAP、SAT、FAIL。
>
> 第一个wrap是默认的行为，即折返，实际可以看作是不处理，仍然读取当前的结果，比如8位无符号数255，再加1，就溢出了，实际的结果就是当前的所有位的值都为0，那么这种行为就会读取到0。同样的，对于8位有符号数127，加1，符号位变成1，数字就成为负数，结果是-128。
>
> 第二个sat是截断行为，就是在发生溢出行为后，把当前值设置为对应情况的极限值，比如8位的无符号数250，有增加10，结果的260是溢出的，那么实际的结果就是极限的255。如果是8位的有符号数-120，有减10，结果-130也是溢出的，这里向下的极限值就是-128，也就是最后的结果。
>
> ```
> bitfield 键名 overflow sat incrby u或i数量 位置 增值
> ```
>
> 第三个fail，就是发现溢出直接不执行该命令，即结果不变化。
>
> ```
> bitfield 键名 overflow fail incrby u或i数量 位置 增值
> ```

# 提取



# 统计

## HyperLogLog

这是一个去重统计工具，当我们向一个集合中添加数据，可以获得其中的元素个数，但是如果元素数量很大，集合的空间则极为庞大，如果我们只是需要一个大致的数量的话，这个代价是不值得的，而这里的结构就是用极小的空间代价给出较为精确的结果。

> 之所以是大致，自然是算法具有统计性质，而导致存在误差，但是对于大数据而言，且不要求极高的进度的情况下，是可以接受的。

```
pfadd 键名 元素 # 添加元素
pfcount 键名 # 获取元素个数
# 如果一开始有多个这样的键在添加元素， 当出现需求希望几个键的值合并
pfmerge 键1 键2 ...
```

### 内部实现原理

首先，最基础的结构还是使用了位图充当数据存储的容器。

其次，如何估算大致的元素数量，

> 



